/* Automatically generated by Ferrum HDL. */

module top_module
(
    // Inputs
    input wire clk,
    input wire rst,
    input wire btn$0,
    input wire btn$1,
    input wire btn$2,
    input wire btn$3,
    input wire btn$4,
    input wire btn$5,
    input wire btn$6,
    input wire btn$7,
    // Outputs
    output wire anodes$0,
    output wire anodes$1,
    output wire anodes$2,
    output wire anodes$3,
    output wire seg$0,
    output wire seg$1,
    output wire seg$2,
    output wire seg$3,
    output wire seg$4,
    output wire seg$5,
    output wire seg$6,
    output wire dp
);

    assign seg$0 = 1;

    assign seg$1 = 1;

    assign seg$2 = 1;

    assign seg$3 = 1;

    assign seg$4 = 1;

    assign seg$5 = 1;

    assign seg$6 = 1;

    assign dp = 0;

    reg [3:0] dff;
    initial begin
        dff = 4'd0;
    end
    wire [2:0] mux;
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff <= 4'd0;
        else
            dff <= { mux, dff[1 +: 3] == 3'd3 };
    end

    Idx$succ __Idx$succ (
        // Inputs
        .self$(dff[1 +: 3]),
        // Outputs
        .mux(mux)
    );

    wire [7:0] speed;
    assign speed = {
        btn$0,
        btn$1,
        btn$2,
        btn$3,
        btn$4,
        btn$5,
        btn$6,
        btn$7
    };

    reg [7:0] cnt;
    initial begin
        cnt = 8'd0;
    end
    wire [7:0] mux_1;
    always @(posedge clk or posedge rst) begin
        if (rst)
            cnt <= 8'd0;
        else if (dff[0])
            cnt <= mux_1;
    end

    always @(*) begin
        case (cnt >= speed)
            1'h1:
                mux_1 = 8'd0;
            default:
                mux_1 = cnt + 8'd1;
        endcase
    end

    reg [2:0] cnt_1;
    initial begin
        cnt_1 = 3'd0;
    end
    wire [2:0] mux_2;
    always @(posedge clk or posedge rst) begin
        if (rst)
            cnt_1 <= 3'd0;
        else if (dff[0] && ( cnt == 8'd0 ))
            cnt_1 <= mux_2;
    end

    Idx$succ_1 __Idx$succ_1 (
        // Inputs
        .self$(cnt_1),
        // Outputs
        .mux(mux_2)
    );

    Counter$one_hot __Counter$one_hot (
        // Inputs
        .__tmp(cnt_1),
        // Outputs
        .out(anodes$0),
        .out_1(anodes$1),
        .out_2(anodes$2),
        .out_3(anodes$3)
    );

endmodule

module Idx$succ
(
    // Inputs
    input wire [2:0] self$,
    // Outputs
    output wire [2:0] mux
);

    always @(*) begin
        case (self$ == 3'd3)
            1'h1:
                mux = 3'd0;
            default:
                mux = self$ + 3'd1;
        endcase
    end

endmodule

module Idx$succ_1
(
    // Inputs
    input wire [2:0] self$,
    // Outputs
    output wire [2:0] mux
);

    always @(*) begin
        case (self$ == 3'd3)
            1'h1:
                mux = 3'd0;
            default:
                mux = self$ + 3'd1;
        endcase
    end

endmodule

module Counter$one_hot
(
    // Inputs
    input wire [2:0] __tmp,
    // Outputs
    output wire out,
    output wire out_1,
    output wire out_2,
    output wire out_3
);

    wire [3:0] __tmp_3;
    assign __tmp_3 = { 0, __tmp };

    wire [3:0] val;
    assign val = 4'd1 << ( 4'd3 - __tmp_3 );

    assign out = val[3];

    assign out_1 = val[2];

    assign out_2 = val[1];

    assign out_3 = val[0];

endmodule

